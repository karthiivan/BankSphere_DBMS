# Design Document - BankSphere Render Deployment

## Overview

This design document outlines the deployment architecture and configuration strategy for deploying the BankSphere banking management system to Render.com. The deployment consists of two primary services: a MySQL database service and a Node.js web service, with proper environment configuration, security measures, and verification procedures.

## Architecture

### Deployment Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Render.com Platform                   │
│                                                           │
│  ┌──────────────────────┐      ┌───────────────────┐   │
│  │   Web Service        │      │  MySQL Database   │   │
│  │   (Node.js/Express)  │◄────►│   Service         │   │
│  │                      │      │                   │   │
│  │  - Port: Dynamic     │      │  - Port: 3306     │   │
│  │  - Health: /api/health│     │  - Internal URL   │   │
│  │  - Build: npm install│      │  - Persistent     │   │
│  │  - Start: npm start  │      │    Storage        │   │
│  └──────────────────────┘      └───────────────────┘   │
│           │                                              │
│           │ HTTPS                                        │
└───────────┼──────────────────────────────────────────────┘
            │
            ▼
    ┌───────────────┐
    │   End Users   │
    │   (Browsers)  │
    └───────────────┘
```

### Application Architecture

```
BankSphere System
├── Backend (Node.js/Express)
│   ├── Routes
│   │   ├── /api/auth (Authentication)
│   │   ├── /api/accounts (Account Management)
│   │   ├── /api/transactions (Money Transfers)
│   │   ├── /api/loans (Loan Applications)
│   │   ├── /api/crypto (Cryptocurrency Trading)
│   │   ├── /api/enhanced (AI Chatbot, Fraud Detection)
│   │   ├── /api/biometric (Biometric Auth)
│   │   ├── /api/profile (User Profile)
│   │   └── /api/admin (Admin Dashboard)
│   ├── Middleware
│   │   ├── Security (Helmet, CORS, Rate Limiting)
│   │   ├── Authentication (JWT Verification)
│   │   └── Input Sanitization
│   └── Database Layer
│       └── MySQL Connection Pool
└── Frontend (Static HTML/CSS/JS)
    ├── index.html (Login/Registration)
    ├── enhanced-dashboard.html (Customer Dashboard)
    ├── admin-dashboard.html (Admin Dashboard)
    └── Assets (CSS, JavaScript, Images)
```

## Components and Interfaces

### 1. Database Service Configuration

**Component**: MySQL Database on Render

**Configuration**:
- Database Name: `banksphere`
- User: Auto-generated by Render
- Password: Auto-generated by Render
- Region: Same as web service for low latency
- Plan: Free tier (sufficient for development/testing)

**Connection Details**:
- Internal Database URL: Provided by Render (format: `mysql://user:password@host:port/database`)
- Connection pooling: 10 connections max
- Wait for connections: Enabled
- Connection timeout: Default

**Schema Requirements**:
The database must include the following table groups:

1. **Core Banking Tables**:
   - users (authentication)
   - customers (customer information)
   - accounts (bank accounts)
   - transactions (transaction history)
   - loans (loan applications)

2. **Advanced Feature Tables**:
   - crypto_wallets (cryptocurrency holdings)
   - crypto_transactions (crypto trading history)
   - fraud_alerts (fraud detection logs)
   - chat_messages (AI chatbot conversations)
   - biometric_data (biometric authentication)
   - investment_plans (investment advisory)
   - budgets (budget management)
   - support_tickets (customer support)

### 2. Web Service Configuration

**Component**: Node.js Express Application

**Build Configuration**:
- Build Command: `npm install`
- Start Command: `npm start`
- Node Version: Latest LTS (auto-detected from package.json)
- Environment: Node

**Runtime Configuration**:
- Port: Dynamic (provided by Render via PORT env var)
- Health Check Path: `/api/health`
- Health Check Interval: 30 seconds
- Auto-deploy: Enabled on main branch push

**Environment Variables** (Required):
```
NODE_ENV=production
PORT=<auto-assigned-by-render>
DB_HOST=<render-mysql-internal-host>
DB_USER=<render-mysql-user>
DB_PASSWORD=<render-mysql-password>
DB_NAME=banksphere
DB_PORT=3306
JWT_SECRET=<generated-random-string-32-chars>
SESSION_SECRET=<generated-random-string-32-chars>
```

### 3. Application Entry Point

**Component**: server.js

**Responsibilities**:
- Initialize Express application
- Load environment variables from .env (development) or Render env vars (production)
- Configure middleware (security, CORS, body parsing, authentication)
- Register all API routes
- Serve static frontend files
- Test database connection on startup
- Start HTTP server on dynamic port
- Handle graceful shutdown

**Key Modifications for Render**:
- Port must be read from `process.env.PORT` (Render assigns dynamically)
- CORS must allow the Render-assigned domain
- Database connection must use environment variables
- Health check endpoint must return 200 OK

### 4. Database Connection Layer

**Component**: config/database.js

**Interface**:
```javascript
{
  pool: ConnectionPool,              // MySQL connection pool
  testConnection: () => Promise<boolean>,  // Test DB connectivity
  getConnection: () => Promise<Connection>, // Get connection from pool
  executeQuery: (query, params) => Promise<Results>, // Execute SQL query
  closePool: () => Promise<void>     // Close all connections
}
```

**Configuration**:
- Reads from environment variables (DB_HOST, DB_USER, DB_PASSWORD, DB_NAME, DB_PORT)
- Creates connection pool with 10 max connections
- Implements connection retry logic
- Logs connection status

### 5. Security Middleware

**Component**: middleware/security.js

**Features**:
- Helmet: Sets security HTTP headers
- CORS: Configures cross-origin resource sharing
- Rate Limiting: Prevents brute force attacks (100 requests per 15 minutes)
- Input Sanitization: Prevents XSS and SQL injection
- Audit Logging: Logs all API requests

**Configuration for Production**:
- CORS origin: Render-assigned URL
- Rate limit: Stricter in production
- Helmet: All security headers enabled
- Audit logs: Stored in database

### 6. Authentication Middleware

**Component**: middleware/auth.js

**Interface**:
```javascript
{
  verifyToken: (req, res, next) => void,     // Verify JWT token
  requireAdmin: (req, res, next) => void,    // Require admin role
  requireCustomer: (req, res, next) => void  // Require customer role
}
```

**Token Verification**:
- Reads JWT from Authorization header or cookies
- Verifies signature using JWT_SECRET
- Attaches user data to req.user
- Returns 401 if invalid or expired

## Data Models

### Environment Configuration Model

```javascript
{
  database: {
    host: String,      // DB_HOST from Render
    user: String,      // DB_USER from Render
    password: String,  // DB_PASSWORD from Render
    database: String,  // DB_NAME (banksphere)
    port: Number       // DB_PORT (3306)
  },
  server: {
    port: Number,      // PORT from Render (dynamic)
    nodeEnv: String    // NODE_ENV (production)
  },
  security: {
    jwtSecret: String,     // JWT_SECRET (32+ chars)
    sessionSecret: String  // SESSION_SECRET (32+ chars)
  }
}
```

### Health Check Response Model

```javascript
{
  success: Boolean,      // Always true if server is running
  message: String,       // Status message
  timestamp: String,     // ISO 8601 timestamp
  version: String        // Application version
}
```

## Error Handling

### Database Connection Errors

**Scenario**: Database connection fails on startup

**Handling**:
1. Log detailed error message to console
2. Display connection parameters (without password)
3. Exit process with code 1
4. Render will automatically restart the service
5. After 3 failed restarts, Render marks service as unhealthy

**Prevention**:
- Verify environment variables are set correctly
- Ensure database service is running
- Check network connectivity between services
- Verify database credentials

### Runtime API Errors

**Scenario**: Error occurs during API request processing

**Handling**:
1. Catch error in route handler or global error middleware
2. Log error details (stack trace in development only)
3. Return appropriate HTTP status code (400, 401, 403, 404, 500)
4. Return JSON error response with message
5. Hide sensitive details in production

**Error Response Format**:
```javascript
{
  success: false,
  message: String,  // User-friendly error message
  error: String,    // Error code (optional)
  stack: String     // Stack trace (development only)
}
```

### Health Check Failures

**Scenario**: Health check endpoint returns non-200 status

**Handling**:
1. Render marks service as unhealthy
2. Render stops routing traffic to the instance
3. Render attempts to restart the service
4. If health check continues to fail, alert is triggered

**Prevention**:
- Ensure `/api/health` route is registered
- Return 200 status with valid JSON
- Keep health check logic simple (no database queries)

## Testing Strategy

### Pre-Deployment Testing

**Local Environment Testing**:
1. Set up local MySQL database with complete schema
2. Configure .env file with local database credentials
3. Run `npm install` to install dependencies
4. Run `npm start` to start server locally
5. Test all API endpoints using Postman or curl
6. Test frontend functionality in browser
7. Verify authentication flows (login, registration, JWT)
8. Test all advanced features (crypto, chatbot, fraud detection)

**Environment Variable Testing**:
1. Create test .env file with production-like values
2. Verify all required variables are read correctly
3. Test with missing variables to ensure proper error handling
4. Verify secrets are not logged or exposed

### Post-Deployment Testing

**Deployment Verification**:
1. Check Render deployment logs for successful build
2. Verify "Database connected successfully" message in logs
3. Verify "Server running on port X" message in logs
4. Check health check endpoint: `https://banksphere.onrender.com/api/health`
5. Verify response is 200 OK with valid JSON

**Functional Testing**:
1. **Authentication**: Test login with default credentials (admin/admin123)
2. **Dashboard**: Verify dashboard loads and displays account data
3. **Transactions**: Test money transfer between accounts
4. **Accounts**: Test account creation and management
5. **Loans**: Test loan application submission
6. **Crypto**: Test cryptocurrency buy/sell operations
7. **Chatbot**: Test AI chatbot message sending
8. **Biometric**: Test biometric authentication registration
9. **Admin**: Test admin dashboard and user management

**Performance Testing**:
1. Test response times for API endpoints (should be < 500ms)
2. Test concurrent user load (simulate 10-20 simultaneous users)
3. Monitor database connection pool usage
4. Check memory usage and CPU utilization in Render dashboard

**Security Testing**:
1. Verify HTTPS is enforced (HTTP redirects to HTTPS)
2. Test rate limiting (should block after 100 requests in 15 minutes)
3. Test SQL injection prevention (try malicious inputs)
4. Test XSS prevention (try script injection in forms)
5. Verify JWT token expiration and validation
6. Test CORS policy (should block unauthorized origins)

### Monitoring and Maintenance

**Render Dashboard Monitoring**:
- Check service status (running/stopped)
- Monitor CPU and memory usage
- Review deployment logs for errors
- Check health check status
- Monitor request metrics

**Database Monitoring**:
- Check database connection count
- Monitor query performance
- Review slow query logs
- Check database storage usage
- Verify backup status

**Alerting**:
- Set up Render alerts for service downtime
- Configure alerts for high error rates
- Monitor database connection failures
- Track response time degradation

## Deployment Workflow

### Initial Deployment Steps

1. **Prepare Repository**:
   - Ensure all code is committed to Git
   - Push to GitHub repository
   - Verify render.yaml is in root directory

2. **Create Database Service**:
   - Log in to Render dashboard
   - Create new MySQL database
   - Note internal connection URL
   - Import database schema using SQL file or script

3. **Create Web Service**:
   - Create new Web Service in Render
   - Connect GitHub repository
   - Configure build and start commands
   - Set environment variables
   - Deploy service

4. **Verify Deployment**:
   - Check deployment logs
   - Test health check endpoint
   - Test API endpoints
   - Test frontend access
   - Verify all features work

### Update Deployment Process

1. **Code Changes**:
   - Make changes locally
   - Test thoroughly in local environment
   - Commit and push to GitHub

2. **Automatic Deployment**:
   - Render detects push to main branch
   - Automatically triggers new deployment
   - Runs build command
   - Starts new instance
   - Switches traffic to new instance

3. **Rollback Process** (if needed):
   - Go to Render dashboard
   - Select previous deployment
   - Click "Redeploy"
   - Render switches back to previous version

## Configuration Files

### render.yaml

Purpose: Defines Render service configuration for automatic deployment

Key Sections:
- Service type (web)
- Build and start commands
- Environment variables (with sync: false for secrets)
- Health check path
- Plan selection (free tier)

### package.json

Purpose: Defines Node.js dependencies and scripts

Key Sections:
- Dependencies: All npm packages required
- Scripts: start, dev, test commands
- Main: Entry point (server.js)

### .env.example

Purpose: Template for environment variables (not used in production)

Usage:
- Developers copy to .env for local development
- Documents required environment variables
- Shows example values (not real credentials)

## Security Considerations

### Secrets Management

- JWT_SECRET: 32+ character random string, never committed to Git
- SESSION_SECRET: 32+ character random string, never committed to Git
- Database credentials: Generated by Render, stored securely
- All secrets stored in Render environment variables (encrypted at rest)

### Network Security

- HTTPS enforced by Render (automatic SSL certificate)
- Database accessible only from internal Render network
- CORS configured to allow only Render-assigned domain
- Rate limiting prevents brute force attacks

### Application Security

- Helmet middleware sets security headers
- Input sanitization prevents XSS and SQL injection
- Passwords hashed with bcrypt (10 rounds)
- JWT tokens expire after 24 hours
- Protected routes require valid JWT token

### Data Security

- Database backups automated by Render
- Sensitive data encrypted in database
- Audit logs track all user actions
- SQL queries use parameterized statements
